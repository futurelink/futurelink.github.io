---
title: Юзаем таймер SysTick для задержек
layout: post
---
Таймер SysTick довольно туп и прост. У прерывания, которое он генерит самый высокий приоритет,
что позволяет его юзать там, гда нужно срочно обработать временное событие.

<!-- more -->

Мне надо было написать либу для работы с трансиверами NRF24. Оно понятно, что либ таких в инете валом
для Адруины или чего еще. Но надо было сделать красиво. Так вот, там надо было сделать задержки в 150мс,
девайс то физический. Наиболее экономично было заюзать SysTick настроенный на 1мс.

Итак, для начала надо его включить:

{% highlight c %}
#define F_CPU 		48000000UL
#define TimerTick	F_CPU/1000

...

	// Запускаем системный таймер
	SysTick->LOAD = TimerTick;
	SysTick->VAL = 0;
	SysTick->CTRL =	SysTick_CTRL_CLKSOURCE_Msk |
	                SysTick_CTRL_TICKINT_Msk   |
	                SysTick_CTRL_ENABLE_Msk;
{% endhighlight %}

У нас проц работет на 48МГц, так что 1мс, это собственно 48 тыс. тактов. Далее фенечка, которую почему-то
никто не юзает в тех либах, которые я видел: я замутил конфиги для модулей трансиверов, т.к. для отладки
оба модуля висят на одном контроллере на разных ногах. Структуру конфига описывать смысла нет, но главное 
там есть переменная счетчика.


{% highlight c %}
//Обработчик прерывания системного таймера
void SysTick_Handler(void)
{
	// Вещаем тиковый счетчик от конфы на прерывание
	// чтобы обеспечить синхронизацию
	NRF24L01_TickCounter(&config1);
	NRF24L01_TickCounter(&config2);

	if (DelayCounter != 0) DelayCounter--;
}
{% endhighlight %}

Функция NR24L01_TickCounter простая. Тут мы делаем обратный отсчет переменной. А собственно там,
где у нас задержка мы просто делаем while(config->DelayCounter) {}. И все.

{% highlight c %}
void NRF24L01_TickCounter(NRF24L01Config *config) {

	// Обратный отсчет для организации задержки
	// на __Systick_Delay
	if (config->DelayCounter != 0) {
		config->DelayCounter--;
	}

	// Мониторим прерывание тут, если получили - тут же получаем статусный
	// регистр и сохраняем его в конфе
	if ((config->GPIO->IDR & config->IRQ_Pin) == 0) {
		uint8_t st = NRF24L01_getRegister(config, NRF_STATUS);

		// Если пришел тип прерывания что есть новые данные, надо
		// вызвать прием и обработку эих данных
		if ((st & NRF_STATUS_RX_DR) != 0) {
			// Сбрасываем прерывание
			//uint8_t t[] =  { NRF_STATUS_RX_DR };
			NRF24L01_setRegister(config, NRF_STATUS, &st, 1);

			// Читаем данные
			if (config->DataRecvHandler != 0) {
				uint8_t buffer[32];	// Максимальная ширина пакета такая
				NRF24L01_recvData(config, buffer, config->PacketWidth);
				config->DataRecvHandler(buffer, config->PacketWidth);
			}

			NRF24L01_setRegister(config, NRF_FLUSH_RX, 0, 0);
		}
	}
}
{% endhighlight %}

Кроме обработки переменной обратного отсчета я сюда впендюрил опрашивалку-читалку входящих данных.
Так как NRF24 устройство-слейв, то его надо постоянно мониторить. Проще всего это делать как раз в
SysTick обработчике. Короче, если нам пришел сигнал о новых данных и мы это узнали тут, то надо их 
прочитать. Прочитали и вызывли функцию обработчика этих данных, которые еиу и перекинули, чтоб прожелвал.
А дальше очистили очередь входящих данных, чтоб не мешались.
